---
title: Contributing
aliases:
  - ../../tutorials/docs-01-contributing-guide/index.html
---

Turing is an open-source project and is [hosted on GitHub](https://github.com/TuringLang).
We welcome contributions from the community in all forms large or small: bug reports, feature implementations, code contributions, or improvements to documentation or infrastructure are all extremely valuable.
We would also very much appreciate examples of models written using Turing.

### How to get involved

Our outstanding issues are tabulated on our [issue tracker](https://github.com/TuringLang/Turing.jl/issues).
Closing one of these may involve implementing new features, fixing bugs, or writing example models.

You can also join the `#turing` channel on the [Julia Slack](https://julialang.org/slack/) and say hello!

If you are new to open-source software, please see [GitHub's introduction](https://guides.github.com/introduction/flow/) or [Julia's contribution guide](https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md) on using version control for collaboration.

### Documentation

Each of the packages in the Turing ecosystem (see [Libraries](/library)) has its own documentation, which is typically found in the `docs` folder of the corresponding package.
For example, the source code for DynamicPPL's documentation can be found in [its repository](https://github.com/TuringLang/DynamicPPL.jl).

The documentation for Turing.jl itself consists of the tutorials that you see on this website, and is built from the separate [`docs` repository](https://github.com/TuringLang/docs).
None of the documentation is generated from the [main Turing.jl repository](https://github.com/TuringLang/Turing.jl); in particular, the API that Turing exports does not currently form part of the documentation.

Other sections of the website (anything that isn't a package, or a tutorial) – for example, the list of libraries – is built from the [`turinglang.github.io` repository](https://github.com/TuringLang/turinglang.github.io).

### Tests

Turing, like most software libraries, has a test suite. You can run the whole suite by running `julia --project=.` from the root of the Turing repository, and then running

```julia
import Pkg; Pkg.test("Turing")
```

The test suite subdivides into files in the `test` folder, and you can run only some of them using commands like

```julia
import Pkg; Pkg.test("Turing"; test_args=["optim", "hmc", "--skip", "ext"])
```

This one would run all files with "optim" or "hmc" in their path, such as `test/optimisation/Optimisation.jl`, but not files with "ext" in their path. Alternatively, you can set these arguments as command line arguments when you run Julia

```julia
julia --project=. -e 'import Pkg; Pkg.test(; test_args=ARGS)' -- optim hmc --skip ext
```

Or otherwise, set the global `ARGS` variable, and call `include("test/runtests.jl")`. 

### Pull requests, versions, and releases

We merge all code changes through pull requests on GitHub. To make a contribution to one of the Turing packages, fork it on GitHub, start a new branch on your fork, and add commits to it. Once you're done, open a pull request to the main repository under [TuringLang](https://github.com/TuringLang). Someone from the dev team will review your code (if they don't, ping `@maintainers` in a comment to get their attention) and check that the continuous integration tests pass. If all looks good, we'll merge your PR with much joy and gratefulness. If not, we'll help you fix it and then merge it with much joy and gratefulness.

All of the below applies to both the Turing.jl and DynamicPPL.jl repositories. Most of it also applies to other repositories under the TuringLang ecosystem, though some do not bother with the `main`/`breaking` distinction or with a `HISTORY.md`. As of August 2025 we are slowly moving towards having all repos do the full process, so a new `HISTORY.md` in a repo that doesn't yet have one is always welcome.

#### Branches

Like Julia packages generally, Turing follows [semantic versioning](https://semver.org/). Because of this, we have two long-standing branches in our repository: `main` and `breaking`. All code that gets released as a new version of Turing gets merged into `main`, and a release is made from there. However, any breaking changes should first be merged into `breaking`. `breaking` will then periodically merged into `main`.

The idea is that `breaking` always contains commits that build towards the next breaking release in the semantic versioning sense. That is, if the changes you make might break or change the behaviour of correctly written code that uses Turing.jl, your PR should target the `breaking` branch, and your code should be merged into `breaking`. If your changes cause no such breakage for users, your PR should target `main`. Notably, any bug fixes should merge directly into `main`.

This way we can frequently release new patch version from `main`, while developing breaking changes in parallel on `breaking`. E.g. if the current version is 0.19.3, and someone fixes a bug, we can merge the fix into `main` and release the latest it as 0.19.4. Meanwhile, breaking changes can be developed and merged into `breaking`, which is building towards a release of 0.20.0. Multiple breaking changes may be cumulated into `breaking`, before finally the `breaking`-to-`main` merge is done, and 0.20.0 is released. `breaking` should then immediately start targeting 0.21.

We do not generally bother doing backports of bug fixes, though may consider them in special circumstances.

#### Change history

We keep a cumulative changelog in a file called `HISTORY.md`. It should have an entry for every new breaking release, explaining everything our users need to know about the changes, such as any features that have been deleted, any changes to syntax or interface, etc. Any major new features should also be described in `HISTORY.md`, as may any other changes that are useful for users to know about. Bug fixes generally don't need an entry in `HISTORY.md`. Any new breaking release must have an entry in `HISTORY.md`, entiers for non-breaking releases are optional.

#### Please make mistakes

Getting pull requests from outside the core developer team is one of the greatest joys of open source maintenance, and Turing's community of contributors is its greatest asset. If you are thinking of contributing, please do open a pull request, even an imperfect or half-finished one, or an issue to discuss it first if you prefer. You don't need to nail all of the above details on the first go, the dev team is very happy to help you figure out how to bump version numbers or whether you need to target `main` or `breaking`.

#### For Turing.jl core developers

If you are a core developer of TuringLang, two notes, in addition to the above, apply:
1. You don't need to make your own fork of the package you are editing. Just make a new branch on the main repository, usually named `your-username/change-you-are-making` (we don't strictly enforce this convention though). You should definitely still make a branch and a PR, and never push directly to `main` or `breaking`.
2. You can make a release of the package after your work is merged into `main`. This is done by leaving a comment on the latest commit on `main`, saying

```
@JuliaRegistrator register

Release notes:
[YOUR RELEASE NOTES HERE]
```

The `@JuliaRegistrator` bot will handle creating a pull request into the Julia central package repository and tagging a new release in the repository. The release notes should be a copy-paste of the notes written in `HISTORY.md` if such an entry exists, or otherwise (for a patch release) a short summary of changes.

Even core devs should always merge all their code through pull requests into `main` or `breaking`. All code should generally be reviewed by another core developer and pass continuous integration (CI) checks. Exceptions can be made in some cases though, such as ignoring failing CI checks where the cause is known and not due to the current pull request, or skipping code review when the pull request author is an experienced developer of the package and the changes are utterly trivial.

### Code Formatting

Turing uses [JuliaFormatter.jl](https://github.com/domluna/JuliaFormatter.jl) to ensure consistent code style across the codebase.
**All code must be formatted before submitting a pull request**, and ideally with every commit.

#### Installing JuliaFormatter

We use version 1 of JuliaFormatter.
Install it in your **global Julia environment** (not the project environment, as adding it to the `Project.toml` would make it an invalid dependency of the project):

```julia
julia -e 'using Pkg; Pkg.add(name="JuliaFormatter", version="1"); Pkg.pin("JuliaFormatter")'
```

#### Formatting Code

To format all Julia files in the current directory and subdirectories:

```julia
julia -e 'using JuliaFormatter; format(".")'
```

Run this command from the root of the repository before committing your changes.
This ensures your code follows the project's formatting standards and maintains consistency across the codebase.

### Style Guide

Turing has a style guide, described below.
Reviewing it before making a pull request is not strictly necessary, but you may be asked to change portions of your code to conform with the style guide before it is merged.

Most Turing code follows [Blue: a Style Guide for Julia](https://github.com/JuliaDiff/BlueStyle).
These conventions were created from a variety of sources including Python's [PEP8](http://legacy.python.org/dev/peps/pep-0008/), Julia's [Notes for Contributors](https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md), and Julia's [Style Guide](https://docs.julialang.org/en/v1/manual/style-guide/).

#### Synopsis

  - Use 4 spaces per indentation level, no tabs.
  - Try to adhere to a 92 character line length limit.
  - Use upper camel case convention for [modules](https://docs.julialang.org/en/v1/manual/modules/) and [types](https://docs.julialang.org/en/v1/manual/types/).
  - Use lower case with underscores for method names (note: Julia code likes to use lower case without underscores).
  - Comments are good, try to explain the intentions of the code.
  - Use whitespace to make the code more readable.
  - No whitespace at the end of a line (trailing whitespace).
  - Avoid padding brackets with spaces. ex. `Int64(value)` preferred over `Int64( value )`.

#### A Word on Consistency

When adhering to the Blue style, it's important to realize that these are guidelines, not rules. This is [stated best in the PEP8](http://legacy.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds):

> A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is most important.

> But most importantly: know when to be inconsistent – sometimes the style guide just doesn't apply. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask!

