---
title: Stochastic Gradient Samplers
engine: julia
---

```{julia}
#| echo: false
#| output: false
using Pkg;
Pkg.instantiate();
```

Turing.jl provides stochastic gradient-based MCMC samplers: **Stochastic Gradient Langevin Dynamics (SGLD)** and **Stochastic Gradient Hamiltonian Monte Carlo (SGHMC)**. 

## Current Capabilities

The current implementation in Turing.jl is primarily useful for:
- **Research purposes**: Studying stochastic gradient MCMC methods
- **Streaming data**: When data arrives continuously
- **Experimental applications**: Testing stochastic sampling approaches

**Important**: The current implementation computes full gradients with added stochastic noise rather than true mini-batch stochastic gradients. This means these samplers don't currently provide the computational benefits typically associated with stochastic gradient methods for large datasets. They require very careful hyperparameter tuning and often perform slower than standard samplers like HMC or NUTS for most practical applications.

## Setup

```{julia}
using Turing
using Distributions
using StatsPlots
using Random
using LinearAlgebra

Random.seed!(123)

# Disable progress bars for cleaner output
Turing.setprogress!(false)
```

## SGLD (Stochastic Gradient Langevin Dynamics)

SGLD adds properly scaled noise to gradient descent steps to enable MCMC sampling. The key insight is that the right amount of noise transforms optimization into sampling from the posterior distribution.

Let's start with a simple Gaussian model:

```{julia}
# Generate synthetic data
true_μ = 2.0
true_σ = 1.5
N = 100
data = rand(Normal(true_μ, true_σ), N)

# Define a simple Gaussian model
@model function gaussian_model(x)
    μ ~ Normal(0, 10)
    σ ~ truncated(Normal(0, 5); lower=0)
    
    for i in 1:length(x)
        x[i] ~ Normal(μ, σ)
    end
end

model = gaussian_model(data)
```

SGLD requires very small step sizes to ensure stability. We use a `PolynomialStepsize` that decreases over time. Note: Currently, `PolynomialStepsize` is the primary stepsize schedule available in Turing for SGLD:

```{julia}
# SGLD with polynomial stepsize schedule
# stepsize(t) = a / (b + t)^γ
sgld_stepsize = Turing.PolynomialStepsize(0.0001, 10000, 0.55)
chain_sgld = sample(model, SGLD(stepsize=sgld_stepsize), 5000)

summarystats(chain_sgld)
```


```{julia}
plot(chain_sgld)
```

## SGHMC (Stochastic Gradient Hamiltonian Monte Carlo)

SGHMC extends HMC to the stochastic gradient setting by incorporating friction to counteract the noise from stochastic gradients:

```{julia}
# SGHMC with very small learning rate
chain_sghmc = sample(model, SGHMC(learning_rate=0.00001, momentum_decay=0.1), 5000)

summarystats(chain_sghmc)
```

```{julia}
plot(chain_sghmc)
```

## Comparison with Standard HMC

For comparison, let's sample the same model using standard HMC:

```{julia}
chain_hmc = sample(model, HMC(0.01, 10), 1000)

println("True values: μ = ", true_μ, ", σ = ", true_σ)
summarystats(chain_hmc)
```

Compare the trace plots to see how the different samplers explore the posterior:

```{julia}
p1 = plot(chain_sgld[:μ], label="SGLD", title="μ parameter traces")
hline!([true_μ], label="True value", linestyle=:dash, color=:red)

p2 = plot(chain_sghmc[:μ], label="SGHMC")
hline!([true_μ], label="True value", linestyle=:dash, color=:red)

p3 = plot(chain_hmc[:μ], label="HMC")
hline!([true_μ], label="True value", linestyle=:dash, color=:red)

plot(p1, p2, p3, layout=(3,1), size=(800,600))
```

The comparison shows that:
- **SGLD** exhibits slower convergence and higher variance due to the injected noise, requiring longer chains to achieve stable estimates
- **SGHMC** shows slightly better mixing than SGLD due to the momentum term, but still requires careful tuning
- **HMC** converges quickly and efficiently explores the posterior, demonstrating why it's preferred for small to medium-sized problems

## Bayesian Linear Regression Example

Here's a more complex example using Bayesian linear regression:

```{julia}
# Generate regression data
n_features = 3
n_samples = 100
X = randn(n_samples, n_features)
true_β = [0.5, -1.2, 2.1]
true_σ_noise = 0.3
y = X * true_β + true_σ_noise * randn(n_samples)

@model function linear_regression(X, y)
    n_features = size(X, 2)
    
    # Priors
    β ~ MvNormal(zeros(n_features), 3 * I)
    σ ~ truncated(Normal(0, 1); lower=0)
    
    # Likelihood
    y ~ MvNormal(X * β, σ^2 * I)
end

lr_model = linear_regression(X, y)
```

Sample using the stochastic gradient methods:

```{julia}
# Very conservative parameters for stability
sgld_lr_stepsize = Turing.PolynomialStepsize(0.00005, 10000, 0.55)
chain_lr_sgld = sample(lr_model, SGLD(stepsize=sgld_lr_stepsize), 5000)

chain_lr_sghmc = sample(lr_model, SGHMC(learning_rate=0.00005, momentum_decay=0.1), 5000)

chain_lr_hmc = sample(lr_model, HMC(0.01, 10), 1000)
```

Compare the results to evaluate the performance of stochastic gradient samplers on a more complex model:

```{julia}
println("True β values: ", true_β)
println("True σ value: ", true_σ_noise)
println()

println("SGLD estimates:")
summarystats(chain_lr_sgld)
```

The linear regression example demonstrates that stochastic gradient samplers can recover the true parameters, but:
- They require significantly longer chains (5000 vs 1000 for HMC)
- The estimates may have higher variance
- Convergence diagnostics should be carefully examined before trusting the results

## Automatic Differentiation Backends

Both samplers support different AD backends. For more information about automatic differentiation in Turing, see the [Automatic Differentiation](../automatic-differentiation/) documentation.

```{julia}
using ADTypes

# ForwardDiff (default) - good for few parameters
sgld_forward = SGLD(stepsize=sgld_stepsize, adtype=AutoForwardDiff())

# ReverseDiff - better for many parameters  
sgld_reverse = SGLD(stepsize=sgld_stepsize, adtype=AutoReverseDiff())

# Zygote - good for complex models
sgld_zygote = SGLD(stepsize=sgld_stepsize, adtype=AutoZygote())
```

## Best Practices and Recommendations

### When to Consider Stochastic Gradient Samplers

- **Streaming data**: When data arrives continuously and you need online inference
- **Research**: For studying stochastic gradient MCMC methods
- **Educational purposes**: For understanding stochastic gradient MCMC algorithms

### Critical Hyperparameters

**For SGLD:**
- Use `PolynomialStepsize` with very small initial values (≤ 0.0001)
- Larger `b` values in `PolynomialStepsize(a, b, γ)` provide more stability
- The stepsize decreases as `a / (b + t)^γ`

**For SGHMC:**
- Use extremely small learning rates (≤ 0.00001)
- Momentum decay (friction) typically between 0.1-0.5
- Higher momentum decay improves stability but slows convergence

### Current Limitations

1. **No mini-batching**: Full gradients are computed despite "stochastic" name
2. **Hyperparameter sensitivity**: Requires extensive tuning
3. **Computational overhead**: Often slower than HMC/NUTS for small-medium datasets
4. **Convergence**: Typically requires longer chains

### General Recommendations

- **Start conservatively**: Use very small step sizes initially
- **Monitor convergence**: Check trace plots and diagnostics carefully  
- **Compare with HMC/NUTS**: Validate results when possible
- **Consider alternatives**: For most applications, HMC or NUTS will be more efficient

## Summary

Stochastic gradient samplers in Turing.jl provide an interface to gradient-based MCMC methods with added stochasticity. While designed for large-scale problems, the current implementation uses full gradients, making them primarily useful for research or specialized applications. For most practical Bayesian inference tasks, standard samplers like HMC or NUTS will be more efficient and easier to tune.